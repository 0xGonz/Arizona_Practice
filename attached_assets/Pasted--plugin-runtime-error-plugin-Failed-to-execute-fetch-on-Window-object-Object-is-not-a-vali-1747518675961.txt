[plugin:runtime-error-plugin] Failed to execute 'fetch' on 'Window': '[object Object]' is not a valid HTTP method.
/home/runner/workspace/client/src/lib/queryClient.ts:16:23
14 |  ): Promise<any> {
15 |    try {
16 |      const res = await fetch(url, {
   |                        ^
17 |        method,
18 |        headers: data ? { "Content-Type": "application/json" } : {},

    at apiRequest /home/runner/workspace/client/src/lib/queryClient.ts:16:23
    at queryFn /home/runner/workspace/client/src/hooks/useEmployeeAnalysis.ts:31:20
    at Object.fetchFn [as fn] (https://8756e596-3251-46b9-a770-82ca5d853cb8-00-1awbjhqwhhqhr.picard.replit.dev/@fs/home/runner/workspace/node_modules/.vite/deps/@tanstack_react-query.js?v=cc1a86dd:840:14
Click outside, press Esc key, or fix the code to dismiss.
You can also disable this overlay by setting server.hmr.overlay to false in vite.config.js.
ChatGPT said:

Thought for 9 seconds
That runtime message means the method you hand off to fetch() is not a string—it’s the whole options object you meant to pass as the second argument. In other words, when you write:

ts
Copy
Edit
api.get('/api/analytics/employee/summary', { params: range })
your wrapper does something like

ts
Copy
Edit
apiRequest(url, { params })
but apiRequest() currently thinks the 2nd arg is always the HTTP‑method string, so it forwards that entire object as method:.

Quick‑fix patch (client/src/lib/queryClient.ts)
ts
Copy
Edit
// BEFORE  (line numbers approximate)
export async function apiRequest(
  url: string,
  method: string = 'GET',
  data?: any,
) {
  const res = await fetch(url, {              // ❌ method is an object!
    method,
    headers: data ? { 'Content-Type': 'application/json' } : {},
    body: data ? JSON.stringify(data) : undefined,
  });
  ...
}
ts
Copy
Edit
// AFTER — accept a config object instead of overloading the 2nd arg
type RequestOpts = {
  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  data?: any;
  params?: Record<string, any>;
};

export async function apiRequest(
  url: string,
  opts: RequestOpts = {},
) {
  const { method = 'GET', data, params } = opts;

  // attach ?key=value when params provided
  const urlObj = new URL(url, window.location.origin);
  if (params) Object.entries(params).forEach(([k, v]) => urlObj.searchParams.set(k, String(v)));

  const res = await fetch(urlObj.toString(), {
    method,
    headers: data ? { 'Content-Type': 'application/json' } : {},
    body: data ? JSON.stringify(data) : undefined,
  });
  if (!res.ok) throw new Error(await res.text());
  return res.json();
}
Update the tiny wrapper helpers
ts
Copy
Edit
export const api = {
  get:  (url: string, opts = {}) => apiRequest(url, { ...opts, method: 'GET' }),
  post: (url: string, data: any)   => apiRequest(url, { method: 'POST', data }),
  // … other verbs if needed
};
Hooks stay exactly the same
ts
Copy
Edit
// useEmployeeAnalysis.ts
return useQuery(
  ['emp-summary', range],
  () => api.get('/api/analytics/employee/summary', { params: range }),
);
Because api.get() now passes { method:'GET', params }, apiRequest() receives a proper options object, and fetch() gets a plain string for its method.

Why the dashboard never crashed
The original dashboard probably called apiRequest(url, 'GET') directly, so method was the correct string. The new hooks used the helper that forwards an object, revealing the mismatch.